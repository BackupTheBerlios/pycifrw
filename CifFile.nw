<<Copyright statement>>=
"""
1.This Software copyright © Australian Synchrotron Research Program Inc, ("ASRP").

2.Subject to ensuring that this copyright notice and licence terms
appear on all copies and all modified versions, of PyCIFRW computer
code ("this Software"), a royalty-free non-exclusive licence is hereby
given (i) to use, copy and modify this Software including the use of
reasonable portions of it in other software and (ii) to publish,
bundle and otherwise re-distribute this Software or modified versions
of this Software to third parties, provided that this copyright notice
and terms are clearly shown as applying to all parts of software
derived from this Software on each occasion it is published, bundled
or re-distributed.  You are encouraged to communicate useful
modifications to ASRP for inclusion for future versions.

3.No part of this Software may be sold as a standalone package.

4.If any part of this Software is bundled with Software that is sold,
a free copy of the relevant version of this Software must be made
available through the same distribution channel (be that web server,
tape, CD or otherwise).

5.It is a term of exercise of any of the above royalty free licence
rights that ASRP gives no warranty, undertaking or representation
whatsoever whether express or implied by statute, common law, custom
or otherwise, in respect of this Software or any part of it.  Without
limiting the generality of the preceding sentence, ASRP will not be
liable for any injury, loss or damage (including consequential loss or
damage) or other loss, loss of profits, costs, charges or expenses
however caused which may be suffered, incurred or arise directly or
indirectly in respect of this Software.

6. This Software is not licenced for use in medical applications.
"""

@ \section{Introduction}

This file implements a general CIF reading/writing utility.  A class
is initialised with either no arguments (a new CIF file) or with the
name of an already existing CIF file.  Data items are accessed/changed/
added using the python mapping type ie to get [[dataitem]] you would
type [[value = cf[blockname][dataitem]]]. 

The methods available for the CifFile type are:
\begin{enumerate}
\item [[ReadCif(filename)]]: (re)initialise using Cif file [[filename]].
\item [[NewBlock(blockname,[block contents])]]: add new block to this object. Returns new
block name, which will not be the requested name if the Cif object 
already has the requested name.  If [[blockcontents]] is provided, it
must be a CifBlock object (see below).
\item [[WriteOut(comment)]]: return the contents of the current file as a
CIF-conformant string, with optional [[comment]] at the beginning.
\end{enumerate}

The methods available for the CifBlock type are:
\begin{enumerate}
\item [[GetCifItem(itemname)]]: return the value of [[itemname]] in 
current block (equivalent to using [])
\item [[AddCifItem(data)]]: add [[data]] to the current block.  [[data]] is 
a tuple containing either an array of itemnames and an array of arrays of 
data, or else an itemname and a data value for that item.  This method 
is called when setting data using []
\item [[RemoveCifItem(dataname)]]: remove the given Cif dataname from the 
current block.  Same as typing 'del block[item]'
\item [[GetLoop(dataname)]]: for looped data item [[dataname]], get a list
of all itemnames and values co-occurring in this loop.  Returns an error
if [[dataname]] is not in a loop.
\item [[AddLoop(dataname,data)]]: add [[data]] to the loop containing
[[dataname]].  If dataname is not a looped item, an error is returned.
If (data) has the wrong length, an error is returned. 
\item [[AddSaveFrame(framename,frame_data)]]: frame_data is a CifBlock,
and framename is the name to be given to this save frame.  It must differ
from all other save frame names in the CifBlock object.
\end{enumerate}

Note also that a CifFile object can be accessed as a mapping type, ie using
square brackets.  Most mapping operations have been implemented (see below).

We import type objects at the module level, as required by later versions
of Python.

<<*>>=
<<Copyright statement>>
from types import *
import re
<<BlockCollection class>>
<<CifFile class>>
<<CifBlock class>>
<<Define an error class>>
<<CIF Dictionary type>>
<<A valid CIF block>>
<<A valid CIF file>>

@ \section{BlockCollection}

Both CIF files and a collection of save frames look very similar, so we
abstract the common behaviour into the BlockCollection class, and then
inherit from it to make either a CifFile object or a BlockSave object.

<<BlockCollection class>>=
class BlockCollection:
    <<Initialise BC data structures>>
    <<Check data name lengths>>
    <<BC emulation of mapping type>>
    <<Read in a CIF file>>
    <<Add a new data section>>
<<Write out to string representation>>

@ When initialising, we take an optional type tag, which will
be used when printing out as a prefix before each block name.
Usually this will be either "data_" for a data block in a
CIF file, or "save_" for a save frame in a data block.

<<Initialise BC data structures>>=
def __init__(self,datasource=None,strict=1,type_tag=''):
    self.dictionary = {}
    self.type_tag = type_tag
    self.strict = strict
    if isinstance(datasource,DictType):
        for (key,value) in datasource.items():
            self.__setitem__(key,value)
    elif isinstance(datasource,CifFile) or isinstance(datasource,BlockCollection):
        for key,value in datasource.dictionary.items():
            self.dictionary[key] = value.copy()
    if strict:
        self.checklengths()
    self.header_comment = ''

@ Checking item name lengths.  Although the new 1.1 standard allows
very long lines (2048 characters), data names are still restricted
to be no more than 75 characters in length.  We hard code this in.

<<Check data name lengths>>=
def checklengths(self):
    blocks = self.dictionary.items()
    for name,block in blocks:
        toolong = len(filter(lambda a:len(a)>75, block.keys()))
        if toolong:
            print 'Warning: block ' + name + ' has ' + `toolong` + ' overlength data names'
@ Emulation of a mapping type.

<<BC emulation of mapping type>>=
def __str__(self):
    return self.WriteOut()

def __setitem__(self,key,value):
    if isinstance(value,CifBlock):
        self.NewBlock(key,value)
    elif isinstance(value,DictType):
        self.NewBlock(key,CifBlock(value))
    else: raise TypeError

def __getitem__(self,key):
    return self.dictionary[key]

def __delitem__(self,key):
    del self.dictionary[key]

def __len__(self):
    return len(self.dictionary)

def keys(self):
    return self.dictionary.keys()

def has_key(self,key):
    return self.dictionary.has_key(key)

def get(self,key,default=None):
    if self.dictionary.has_key(key):
        return self.dictionary[key]
    else: 
        return default

def clear(self):
    self.dictionary.clear()

def copy(self):   
    newcopy = self.dictionary.copy()
    return BlockCollection('',newcopy)
 
def update(self,adict):
    for key in adict.keys():
        self.dictionary[key] = adict[key]

@ Adding a new block.  A new block is just a new item in our
dictionary, so we add a new entry to the current list of dictionaries, and set
the count of the number of loops to zero.  We return the new block name
in case we have changed it, so the calling routine can refer to it
later.  Also, there is a limit of 75 characters for the block name length,
which we enforce here.

<<Add a new data section>>=
def NewBlock(self,blockname,blockcontents=()):
    if not blockcontents:
        blockcontents = CifBlock()
    newblockname = re.sub('\W','_',blockname)
    blocknames = self.dictionary.keys()
    i = 0
    while blocknames.count(newblockname):
        i = i + 1
        newblockname = newblockname+`i`
    if len(newblockname) > 75:
        raise CifError, 'Cif block/frame name too long:' + newblockname
    if blockcontents.__class__.__name__[-8:] != 'CifBlock':
        raise CifError, 'Cif block initialised with non CifBlock object %s' % blockcontents.__class__.__name__[-8:]
    self.dictionary.update({newblockname:blockcontents})
    return newblockname

@ Writing all this stuff out to a string.  We loop over each of the
individual sections, getting their string representation.  We 
implement this using the cStringIO module for faster work.  Note that
the default output comment specifies a CIF 1.1 standard file.

<<Write out to string representation>>=
    def WriteOut(self,comment=''):
        import cStringIO
        if not comment:
            comment = self.header_comment
        outstring = cStringIO.StringIO()
        outstring.write(comment)
        for datablock in self.dictionary.keys():
            outstring.write('\n' + self.type_tag +datablock+'\n')
            outstring.write(str(self.dictionary[datablock]))
        returnstring =  outstring.getvalue()
        outstring.close()
        return returnstring

@ \section{CifFile}

If we are passed a filename, we open it and read it in, assuming that
it is a conformant Cif file.  A CifFile object is a dictionary of
CifBlock objects, accessed by block name.  As the maximum line length
is subject to change, we allow the length to be specified, with the
current default set at 2048 characters (Cif 1.1).  For reading in files, 
we only
flag a length error if the parameter "strict" is true, in which case
we use parameter maxinlength as our maximum line length on input.  
Parameter maxoutlength sets the maximum line size for output.  If
maxoutlength is not specified, it defaults to the maximum input
length.

Note that this applies to the input only.  For changing output length, 
you can provide an optional parameter in the WriteOut method.

<<CifFile class>>=
class CifFile(BlockCollection):
<<Initialise data structures>>
    <<Read in a CIF file>>

@ When initialising, we add those parts that are unique to the CifFile as
opposed to a simple collection of blocks - i.e. reading in from a file,
and some line length restrictions.  We don't indent this section in the
.nw file, so that our comment characters output at the beginning of the
line.

<<Initialise data structures>>=
    def __init__(self,datasource=None,strict=1,maxinlength=2048,maxoutlength=0):
        BlockCollection.__init__(self,datasource=datasource,strict=strict,type_tag='data_')
        self.maxinlength = maxinlength
        if maxoutlength == 0:
            self.maxoutlength = maxinlength
        else:
            self.maxoutlength = maxoutlength
        if type(datasource) is StringType:
            self.ReadCif(datasource,strict,maxinlength)
        self.header_comment = \
"""#\\#CIF1.1
##########################################################################
#               Crystallographic Information Format file 
#               Produced by PyCifRW module
# 
#  This is a CIF file.  CIF has been adopted by the International
#  Union of Crystallography as the standard for data archiving and 
#  transmission.
#
#  For information on this file format, follow the CIF links at
#  http://www.iucr.org
##########################################################################
"""

@ Reading in a file.  We now use the Yapps2-generated YappsCifParser module to provide grammar
services.  The structure returned from parsing is an array of blocks,
which we convert to a dictionary and place in [[self.dictionary]].  We do a preliminary
check of line length, to satisfy the standard.

<<Read in a CIF file>>=
def ReadCif(self,filename,strict,maxlength):
    import YappsCifParser,string
    stream = open(filename,'r')
    text = stream.read()
    stream.close()
    if not text:      # empty file, return empty block
        return
    split = string.split(text,'\n')
    if strict:
        toolong =  filter(lambda a:len(a)>maxlength, split)
        if toolong:
            pos = split.index(toolong[0])
            raise CifError, 'Line %d contains more than %d characters' % (pos+1,maxlength)
    context = {"loops":[],"latest":{}}
    try: 
        parser = YappsCifParser.CifParser(YappsCifParser.CifParserScanner(text))
        filecontents = getattr(parser,"input")()
    except YappsCifParser.SyntaxError:
        errorstring = 'Syntax error in input file: last value parsed was %s' % YappsCifParser.lastval
        errorstring = errorstring + '\nParser status: %s' % `parser._scanner`
        raise CifError, errorstring
    else:
        if not filecontents: # comments only, return empty
            return
    for block in filecontents.keys():
        self.dictionary.update({block:CifBlock(filecontents[block])})

@ \section{Cif Block class}

A Cif Block is essentially a dictionary with a few extra items
for our own internal reference.  These are used to handle loop
management, so that data belonging within one loop are able to
be handled together when printing out.  When initialising, we
allow either a set of tuples, suitable for input to AddCifItem,
or a complete block, suitable when copying.

A new feature is availability of save frames.  They are invisible,
except when referenced directly using the key "saves".

<<CifBlock class>>=
class CifBlock:
    <<Initialise Cif Block>>
    <<Add emulation of a mapping type>>
    <<Return value of Cif item>>
    <<Remove a data item>>
    <<Add a data item>>
    <<Check data name for CIF conformance>>
    <<Check data item for CIF conformance>>
    <<Regularise data values>>
    <<Get complete looped data>>
    <<Add to looped data>>
    <<Add a save frame>>
    <<Print a data block>>
    <<Format a string>>

@ If given non-zero data to initialise the block with, we either
copy (if it is a dictionary) or else initialise each key-value
pair separately (if tuples).  We take care to include our special
"loop" key if it is not in the supplied dictionary, but apart from
this we make no check of the actual conformance of the dictionary
items.  If given a maximum output line length, we save that for
use in writing out lines.  We use the wraplength parameter to try
to wrap nicely; however, if we are given very long data, we will
continue on until we get to maxoutlength characters.

<<Initialise Cif Block>>=
def __init__(self,data = (),maxoutlength=2048,wraplength=80):
    self.block = {"loops":[],"saves":BlockCollection(type_tag="save_")}
    self.maxoutlength = maxoutlength
    self.wraplength = wraplength
    if type(data) is DictType:     #direct placement
        self.block.update(data)
	# convert any save frames to CifBlocks
	sbs = self.block["saves"]  #shorthand
	self.block["saves"] = BlockCollection(datasource=sbs,type_tag="save_")
    elif type(data) is TupleType:
        for item in data:
            self.AddCifItem(item)
    else:                          #assume is CifBlock
        self.block = data.block.copy()

@ Adding emulation of a mapping type.  We add any of the other
functions we'd like to emulate.   [[__len__]] returns the number
of CIF items in this block, either in a loop or not.  So it is
not the simple length of the dictionary.  It also completely
ignores the "saves" key.

<<Add emulation of a mapping type>>=
def __str__(self):
    return self.printsection()

def __setitem__(self,key,value):
    self.AddCifItem((key,value))

def __getitem__(self,key):
    return self.GetCifItem(key)

def __delitem__(self,key):
    self.RemoveCifItem(key)

def __len__(self):
    blen = len(self.block) - 1   #non-looped items
    if self.block.has_key("saves"): blen = blen - 1  #not counted 
    for aloop in self.block["loops"]:
        blen = blen + len(aloop.keys())
    return blen    

def __nonzero__(self):
    if self.__len__() > 0: return 1
    return 0

# keys ignores the "saves" key
def keys(self):
    thesekeys = self.block.keys()
    for aloop in self.block["loops"]:
        thesekeys.extend(aloop.keys())
    try:
        thesekeys.remove("saves")
	thesekeys.remove("loops")
    except ValueError:
        pass
    return thesekeys

def values(self):
    ourkeys = self.keys()
    return map(lambda a:self[a],ourkeys)

def has_key(self,key):
    if self.block.has_key(key):
        return 1
    for aloop in self.block["loops"]:
        if aloop.has_key(key):
            return 1
    return 0

def get(self,key,default=None):
    if self.has_key(key):
        retval = self.GetCifItem(key)
    else:
        retval = default
    return retval

def clear(self):
    self.block = self.NewBlock()

def copy(self):
    newcopy = self.block.copy()
    newcopy["loops"] = []
    for aloop in self.block["loops"]:  # do a deeper copy
        newcopy["loops"].append(aloop.copy())
    if self.block.has_key("saves"):    # a block collection object
        newcopy["saves"] = self.block["saves"].copy()
    return CifBlock(newcopy)

# this is not appropriate for save blocks.  Instead, the save block
# should be accessed directly for update
 
def update(self,adict):
    loopdone = []
    if not isinstance(adict,CifBlock):
        raise TypeError
    for key in adict.block.keys():
        if key!="loops":
            self.AddCifItem((key,adict[key]))
        else:
            for aloop in adict.block["loops"]:
                self.AddCifItem((aloop.keys(),aloop.values()))

@ Returning a Cif item value.  Note that a looped block has little
meaning without all the items in the loop.  Routine [[GetLoop]] is
better in this case.

<<Return value of Cif item>>=
def GetCifItem(self,itemname):
    if self.block.has_key(itemname):
        return self.block[itemname]
    else:
        for aloop in self.block["loops"]:
            if aloop.has_key(itemname):
                return aloop[itemname]
    raise KeyError, 'Item %s not in Cif block' % itemname

@ This function is required if we wish a list of all items in a data block.
We would use this if we needed to match things up properly.  We give the name
of one item, and all items from that loop, and their values, are returned.
As we are using the built-in [[items]] method of dictionaries, the returned
values are a series of key,value pairs. 

Also, it would be nice if the return value is in a form that can be
fed right back into the file.  So if we are asked for an item which is
part of a loop, we reconstruct all of the data before returning it.

<<Get complete looped data>>=
def GetLoop(self,itemname):
    for aloop in self.block["loops"]:
        if aloop.has_key(itemname):
            return aloop.items()
    # not a looped item
    if self.block.has_key(itemname):
        raise TypeError, 'Non-looped item'
    raise KeyError, 'Item not in loop'

@ Adding to a loop.  We find the loop number containing the dataname that
we've been passed, and then append all of the (key,values) pairs that we
are passed in [[data]], which is a dictionary.  We expect that the data 
have been sorted out for us, unlike when data are passed in [[AddCifItem]], 
when there can be both unlooped and looped data in one set.  The dataname 
passed to this routine is simply a convenient way to refer to the
loop, and has no other significance.

<<Add to looped data>>=
def AddToLoop(self,dataname,loopdata):
    found = 0
    for aloop in self.block["loops"]:
        if aloop.has_key(dataname):
            found = 1
            for itemname in loopdata.keys():
                if len(loopdata[itemname])!= len(aloop[dataname]):
                    raise CifError, 'Datalength mismatch adding to loop: %s and %s' % (itemname, dataname)
                aloop.update({itemname:loopdata[itemname]})
    if not found:
        raise KeyError, 'No such looped item name: %s' % dataname

@ Adding a save frame.  The name must be unique, and the data must be
a CifBlock with no nested save frames!  As with block names, if this
frame name already exists, another one will be generated, so the
function call returns the new name.  The "saves" key refers to a
CifFile, so we can use the methods defined there to save trouble.

<<Add a save frame>>=
def AddSaveFrame(self,framename,frame_data):
    if not isinstance(frame_data,CifBlock): 
	raise CifError, 'Save frame contents not a CifBlock'
    # as for a new blockname
    newframename = re.sub('\W','_',framename)
    framenames = self.block["saves"].keys()
    i = 0
    while framenames.count(newframename):
        i = i + 1
        newframename = newframename+`i`
    if len(newframename) > 75:
        raise CifError, 'Save frame name too long:' + newframename
    self.block["saves"].update({newframename:frame_data})
    return newframename

@ Removing a data item.  We delete the item, and if it is looped, and
nothing is left in the loop, we remove that element of the list.

<<Remove a data item>>=
def RemoveCifItem(self,itemname):
    if self.block.has_key(itemname):
        del self.block[itemname]
        return
    for aloop in self.block["loops"]:
        if aloop.has_key(itemname):
            del aloop[itemname]
    self.block["loops"] = filter(None, self.block["loops"])

@ Adding a data item.  We are passed a tuple with the (set) of data
names at the beginning, and a (set) of values for them following.  For
efficiency, we want to group looped items together; so in the stored
dictionary, all data items in a loop belong in one dictionary in an
array of dictionaries keyed by the word "loops".

If an item is already stored, it will be silently replaced; if it earlier
lived in a loop, it will be removed from the loop, and the loop itself
removed if it is now zero length.

We check the length of the name, and give an error if the name is
greater than 75 characters, which is the CIF 1.1 maximum length.

We also check for consistency, by making sure the new item is
not in the block already.  If it is, we replace it (consistent with
the meaning of square brackets).  If it is in a loop, we replace the
looped value and all other items in that loop block.  This means
that when adding loops, we must add them all at once if we call
this routine directly.

We typecheck the data items.  They can be tuples, strings
or lists.  If we have a list of values for a single item,
the item name should also occur in a single member tuple.

<<Add a data item>>=
def AddCifItem(self,data):
    # we accept only tuples, strings and lists!!
    if not (isinstance(data[0],StringType) or isinstance(data[0],TupleType)
          or isinstance(data[0],ListType)):
              raise TypeError, 'Cif datanames are either a string, tuple or list'
    # now put into the dictionary properly...
    if isinstance(data[0],StringType):   # a single name
        self.check_data_name(data[0])    # make sure no nasty characters   
        # now make sure the data is OK
        regval = self.regularise_data(data[1])
        self.check_item_value(regval)
        self.block.update({data[0]:regval})  # trust the data is OK
        for aloop in self.block["loops"]:
            if aloop.has_key(data[0]):
                del aloop[data[0]]
        self.block["loops"] = filter(len,self.block["loops"])
    else:                                # we loop
       if(len(data[0])!=len(data[1])):
           raise TypeError, 'Length mismatch between itemnames and values'
       dellist = []
       map (self.check_data_name,data[0])
       for itemname in data[0]:
           self.block["loops"] = filter(lambda a,b=itemname:b not in a.keys(),self.block["loops"])
       newdict = {}
       proper_vals = map(self.regularise_data,data[1])
       map(self.check_item_value,proper_vals)
       map(lambda a,b,c=newdict:c.update({a:b}),data[0],proper_vals)
       self.block["loops"].append(newdict)
    return

@ Checking the data names.  The CIF 1.1 standard restricts characters in
a data name to ASCII 33-126 and there should be a leading underscore.  Items
are allowed to have the blank characters as well, i.e. ascii 09,10,13 and 32.
Data items may be lists, which we need to detect before checking.  We assume
that the item has been regularised before this check is called.

<<Check data name for CIF conformance>>=
def check_data_name(self,dataname): 
    if len(dataname) > 75:
        raise CifError, 'Dataname ' + dataname + ' too long.'
    if dataname[0]!='_':
        raise CifError, 'Dataname ' + dataname + ' does not begin with _'
    if len (filter (lambda a: ord(a) < 33 or ord(a) > 126, dataname)) > 0:
        raise CifError, 'Dataname ' + dataname + ' contains forbidden characters'
 
<<Check data item for CIF conformance>>=
def check_item_value(self,item):
    test_item = item
    if type(item) != TupleType and type(item) != ListType:
       test_item = [item]         #single item list
    def check_one (it):
        if type(it) == StringType:
            if len (filter (lambda a:ord(a) != 9 and ord(a) != 10 and ord(a) != 13
                    and (ord(a) < 32 or ord(a) > 126), it)) > 0:
                raise CifError, 'Data item ' + it + '... contains forbidden characters'
    map(check_one,test_item)

@ Regularising data.  We want the copy.deepcopy operation to work, so
we can't have any arrays passed into the master dictionary.  We make
sure everything goes in either as a single item or as a list/tuple.

<<Regularise data values>>=
def regularise_data(self,dataitem):
    alrighttypes = [IntType, LongType, 
                    FloatType, StringType]
    okmappingtypes = [TupleType, ListType]
    thistype = type(dataitem)
    if thistype in alrighttypes or thistype in okmappingtypes:
        return dataitem
    # so try to make into a list
    try:
        regval = list(dataitem)
    except TypeError, value:
        raise CifError, str(dataitem) + ' is wrong type for data value\n' 
    return regval
    
@ Printing a section.  We allow an optional order list to be given, in
case the caller wants to order things in some nice way.  This is
overridden if any item in the order list occurs within a loop, in
which case it will be packaged together with everything else within
that same loop.  

Note that we must be careful to add spaces between data items, especially
when formatting string loop data, where our string addition could get
quite hairy.  As we are doing so much concatenation, we use a stringIO
buffer to speed it up.

<<Print a data block>>=
def printsection(self,order=[]):
    import cStringIO
    import string
    # first make an ordering
    if not order:
        order = self.keys()
        order.sort()
    # now prune that ordering...
    order = filter(lambda a,b=self.block:b.has_key(a),order)
    # now do it...
    outstring = cStringIO.StringIO()       # the returned string
    # print any save blocks
    if len(self.block["saves"])>0:
	for savename in self.block["saves"].keys():
	   outstring.write("\nsave_%s \n\n" % savename)
	   outstring.write(str(self.block["saves"][savename]))
	   outstring.write("\n\nsave_\n\n")
    for itemname in order:
        itemvalue = self.block[itemname]
        if isinstance(itemvalue,StringType):
              thisstring = self._formatstring(itemvalue)
              if len(thisstring) + len(itemname) < (self.wraplength-2):
                      outstring.write('%s %s\n' % (itemname,thisstring))
              else:
                      outstring.write('%s\n %s\n' % (itemname, thisstring))
        else: 
                  if len(str(itemvalue)) + len(itemname) < (self.wraplength-2):
                      outstring.write('%s %s\n' % (itemname, itemvalue))
                  else:
                      outstring.write('%s\n %s\n' % (itemname, itemvalue))
        continue
    #do the loops
    for aloop in self.block["loops"]:
           outstring.write('\n loop_\n')
           loopnames = aloop.keys()
           loopnames.sort()
           numdata = len(aloop[loopnames[0]])
           for name in loopnames: 
               outstring.write('   %-75s\n' % name)
               if len(aloop[name]) != numdata:
                   raise CifError,'Loop data mismatch for ' + name + \
                   ':output aborted\n'+ '%d , expected %d:' % \
                   (len(aloop[name]),numdata) + `aloop[loopnames[0]]`+`aloop[name]` + outstring.getvalue()
           curstring = ''      
           # when adding to outstring, make sure to add spaces
           for position in range(numdata):
               for name in loopnames:
                   # at each point, get the next data value
                   datapoint = aloop[name][position]
                   if isinstance(datapoint,StringType):
                       thisstring = '%s' % (self._formatstring(datapoint)) #no spaces yet
                       if '\n' in thisstring:
                           # we try to wrap if the first <eol> is bigger than our wrap length
                           if len(curstring) + string.find(thisstring,'\n') > (self.wraplength):
                               outstring.write(' ' + curstring + '\n' + thisstring)
                           else:
                               outstring.write(' ' + curstring + ' ' + thisstring) #a space
                           curstring = ''
                           continue
                   else: 
                       thisstring = ' %s ' % datapoint
                   if len(curstring) + len(thisstring)> self.wraplength-2: #past end of line with space
                       outstring.write(' ' + curstring+'\n') #add the space
                       curstring = ''
                   curstring = curstring + ' ' + thisstring
               outstring.write(' ' + curstring + '\n')    #last time through
               curstring = ''
    returnstring = outstring.getvalue()
    outstring.close()
    return returnstring

@ Formatting a string.  We make sure that the length of the item value
is less than [[self.maxoutlength]], or else we should split them, and so on. We check the
value for terminators and impossible apostrophes and length, before
deciding whether to print it and the item on a single line.  We try to
respect carriage returns in the string, if the caller has tried to do
the formatting for us.  If we are not putting apostrophes around a
string, we make the first character a space, to avoid problems if the
first character of a line is a semicolon.

The CIF specification states that embedded quotes are allowed so long
as they are not followed by a space.  So if we find any quotes followed
by spaces we output a semicolon-terminated string to avoid to much
messing around.  This routine is called very often and could be 
improved.

<<Format a string>>=
def _formatstring(self,instring):
    import string
    if len(instring)< (self.maxoutlength-2) and '\n' not in instring and not ('"' in instring and '\'' in instring):
        if not ' ' in instring and not '\t' in instring and not '\v' \
          in instring:                  # no blanks
            return ' %s ' % (instring)
        if not "'" in instring:                                       #use apostrophes
            return "'%s'" % (instring)
        elif not "\"" in instring:
            return '"%s"' % (instring)
    # is a long one or one that needs semicolons due to carriage returns
    outstring = "\n;\n"
    # if there are returns in the string, try to work with them
    while 1:
        retin = string.find(instring,'\n')+1
        if retin < self.maxoutlength and retin > 0:      # honour this break
            outstring = outstring + instring[:retin]
            instring = instring[retin:]
        elif len(instring)<self.maxoutlength:            # finished
            outstring = outstring + instring + '\n;\n'
            break
        else:                             # find a space
            for letter in range(self.maxoutlength-1,40,-1): 
                if instring[letter] in ' \t\f': break
            outstring = outstring + instring[:letter+1]
            outstring = outstring + '\n'
            instring = instring[letter+1:]            
    return outstring

@ Defining an error class: we simply derive a 'nothing' class from the root
Python class

<<Define an error class>>=
class CifError(Exception):
    def __init__(self,value):
        self.value = value
    def __str__(self):
        print '\nCif Format error: '+ self.value 

@ {Section: Dictionaries}

As there are currently two types of dictionaries available, we are
forced to deal with the syntax of both.  But, as both a collection
of save frames and a collection of data blocks are represented by
the same type, normalisation is very easy: in one case we do
nothing, and for DDL2 we return the "saves" item.

@ To check that a CIF is valid, we need at least one dictionary but
perhaps several against which to match it.  A dictionary is optionally
specified during initialisation, and it is a CifFile type.  We call
our small dictionary normalisation function, which enables hiding
of the DDL1/DDL2 save frame/data block syntax differences.

We would like to abstract out the differences in dictionary 
behaviour,  so we define a dictionary class.  Although we could
subclass this from a CifFile, we have inconsistent behaviour in
the a DDL2 dictionary will need to go through the "saves" key to
get the definitions, whereas the DDL1 dictionary will not.   
Furthermore, the data block in the DDL2 dictionary contains useful
information, so we don't want to hide access to that either.

We adopt a data model whereby the excess information in a DDL2
dictionary is absorbed into special methods, which we initialise
ourselves for a DDL1 dictionary.  The square bracket notation
then refers only to the definitions.

Note that the underscore following the data or save frame header is
technically not part of the name, and so in DDL2 dictionaries there are
two underscores after the word "save".  DDL1 people hadn't figured this
out yet, so we have to add it in by changing each block name.

<<CIF Dictionary type>>=
class CifDic(BlockCollection):
    <<Initialise Cif dictionary>>
    <<Dictionary determination function>>
    <<Deal with DDL1 differences>>
    <<Add type information>>
    <<Item-level validation>>

<<Initialise Cif dictionary>>=
def __init__(self,dic_as_cif):
    (self.dicname,self.diclang,self.defdata) = self.dic_determine(dic_as_cif)
    BlockCollection.__init__(self,datasource=self.defdata) 
    # rename and expand out definitions using "_name" in DDL dictionaries
    if self.diclang == "DDL1":
        self.DDL1_normalise()
    # initialise type information
    self.dic_as_cif = dic_as_cif
    self.typedic={}
    self.add_type_info()

@ This function determines whether we have a DDL2 or DDL1 dictionary.

<<Dictionary determination function>>=
def dic_determine(self,cifdic):
    if cifdic.has_key("on_this_dictionary"):   # DDL1
	self.type_spec = "_type"
	self.enum_spec = "_enumeration"
	self.cat_spec = "_category"
	self.loop_spec = "_list"
        self.unique_spec = "_list_uniqueness"
	name = cifdic["on_this_dictionary"]["_dictionary_name"]
	version = cifdic["on_this_dictionary"]["_dictionary_version"]
	return (name+version,"DDL1",cifdic)
    elif len(cifdic.keys()) == 1:              # DDL2
        blockname = self.keys()[0]	
	name = cifdic[blockname]["_dictionary.title"]
	version = cifdic[blockname]["_dictionary.version"]
	if name != blockname:
	    print "Warning: DDL2 blockname %s not equal to dictionary name %s" % (blockname,name)
	self.type_spec = "_item_type.code" 
	self.enum_spec = "_item_enumeration.value"
	self.cat_spec = "_item.category_id" 
	self.loop_spec = "there_is_no_loop_spec!"
        self.unique_spec = "_item.mandatory_code"
	return (name+version,"DDL2",cifdic[name]["saves"])
    else:
	raise CifError, "Unable to determine dictionary DDL version"
    
@ DDL1 differences.  Firstly, in DDL1 you can loop a _name to get
definitions of related names (e.g. x,y,z).  Secondly, the data block
name is missing the initial underscore, so we need to read the _name
value.  There is one block without a _name attribute, which we
proceed to destroy.

<<Deal with DDL1 differences>>=
def DDL1_normalise(self):
    for key,value in self.dictionary.items():
       if value.has_key("_name"):
           real_name = value["_name"]
           if type(real_name) is ListType:        #looped values
               for looped_name in real_name:
                   new_value = value.copy()
                   new_value["_name"] = looped_name  #only looped name
                   self.dictionary[looped_name] = new_value
           else: self.dictionary[real_name] = value
       # delete the old one
       del self.dictionary[key]
    # debug
    open("dic_debug","w").write(self.__str__())
       
@ Some things are independent of where an item occurs in the file; we
check those things here.

<<Item-level validation>>=
<<Validate the type of an item>>
<<Validate an enumeration>>
<<Validate looping properties>>

@ Validate the type of an item

We use the expressions for type that we have available to check that
the type of the item passed to us matches up.  We may have a list of
items, so be aware of that.  We define a tiny matching function so
that we don't have to do a double match to catch the non-matching
case, which returns None and thus an attribute error if we immediately
try to get a group.  

Note also that none of the extant dictionaries use the 'none' or 'seq'
values for type.  The seq value in particular would complicate matters.

<<Validate the type of an item>>=
def validate_type(self,item_name,item_value):
    def mymatch(m,a):  
        res = m.match(a)
        if res != None: return res.group() 
        else: return ""
    target_type = self[item_name][self.type_spec] 
    matchexpr = self.typedic[target_type]
    if isinstance(item_value,StringType): #not looped
	item_values = [item_value]
    else:
	item_values = item_value    #is already in a loop
    #for item in item_values:
        #print "Type match " + item_name + " " + item + ":",
    check_all = filter(lambda a: mymatch(matchexpr,a) != a, item_values)
    if len(check_all)>0: return False
    else: return True

@ Note that we must make a copy of the enum list, otherwise when we
add in our ? and . they will modify the Cif in place, very sneakily,
and next time we have a loop length check, e.g. in writing out, we
will probably have a mismatch.

<<Validate an enumeration>>=
def validate_enum(self,item_name,item_value):
    try: 
        enum_list = self[item_name][self.enum_spec][:]
    except KeyError:
	return None 
    enum_list.append(".")   #default value
    enum_list.append("?")   #unknown
    if isinstance(item_value,StringType): #not looped
	item_values = [item_value]
    else:
	item_values = item_value    #is already in a loop
    print "Enum check: %s in %s" % (`item_values`,`enum_list`)
    check_all = filter(lambda a: a not in enum_list,item_values)
    if len(check_all)>0: return False
    else: return True

@ Check that something can be looped.  For DDL1 we have yes, no and both.
For DDL2 there is no explicit restriction on looping beyond membership in
a category.  Note that the DDL1 core dictionary contains nothing that cannot 
be looped, but the Powder 1.0 dictionary has 4 items.

<<Validate looping properties>>=
def validate_looping(self,item_name,item_value):
    try:
        how_to_loop = self[item_name][self.loop_spec]
    except KeyError:
        return None
    if how_to_loop == 'yes' and isinstance(item_value,StringType): # not looped
        return False      #this could be triggered
    if how_to_loop == 'no' and not isinstance(item_value,StringType): 
        return False      
    return True

@ And some things are related to the group structure.  This gets pretty
divergent for DDL1 and DDL2, so we go separately.

<<Validate loop-level conformance>>=
<<Validate loop membership>>
<<Validate loop key>>

@ Loop membership.  Items must be in the same category.  Note that values are
only needed for the item-level checks, so are not passed to these functions.

The most common constraints on a loop are that all items are from the same
category, and that loops of a certain category must contain a certain key to
be valid.  The latter test should be performed after the former test.

<<Validate loop membership>>=
def validate_loop_membership(self,loop_names):
    try:
        categories = map(lambda a:self[a][self.cat_spec],loop_names)
    except KeyError:       #category is mandatory
        raise CifError, "%s missing from dictionary %s for item in loop containing %s" % (self.cat_spec,self.dicname,loop_names[0])
    if len(filter(lambda a:a != categories[0],categories))>0:
        return False
    else: return True

def validate_loop_key(self,loop_names):
    category = self[loop_name[0]][self.cat_spec]
    # find any unique values which must be present 
    all_names_in_category = map(lambda a:self[a][self.cat_spec]==category,self.keys())
    unique_spec = filter(lambda a:self[a].has_key(self.unique_spec),all_names_in_category)
    for unique_name in unique_spec:
        names_to_check = self[unique_name][self.unique_spec]
        if isinstance(names_to_check,StringType):   #only one
            names_to_check = [names_to_check]
        for loop_key in names_to_check
            if loop_key not in loop_names: return False
    else: return True    
    
@ Preparing our type expressions

In DDL2 dictionaries our type expressions are given in the main
block as POSIX regexps, so we can pass them on to the re package.
For DDL1 dictionaries we could get them from the DDL1 language
definition, but for now we just hard code them.  Essentially only
the number definition is important, as the syntax check on 
reading/writing will catch any char violations.

Note that the python re engine is not POSIX compliant in that it will
not return the longest leftmost match, but rather the first leftmost
match.  So we have reversed the cif_mm dic order in the expression
below.  We also have to add a catchall for default values.

<<Add type information>>=
def add_type_info(self):
    if self.dic_as_cif.has_key("_item_type_list.construct"): #DDL2
	types = self.dic_as_cif["_item_type_list.code"]
	constructs = self.dic_as_cif["_item_type_list.construct"]
    else:   # DDL1
	types = ["char","numb","null"]
	constructs = [".*",
	'(-?(([0-9]*[.][0-9]+)|([0-9]+)[.]?)([(][0-9]+[)])?([eEdD][+-]?[0-9]+)?)|\?|\.',
	""]
    packed_up = map(None,types,constructs)
    for typecode,construct in packed_up:
        self.typedic[typecode] = re.compile(construct,re.MULTILINE|re.DOTALL)

@ {Section: Valid CIFS}

A whole new can of worms is opened up when we require that a CIF is
not only syntactically correct, but valid according to the specified
dictionary.  We have two different DDLs: one has definitions in
separate data blocks, and the other has definitions in save frames,
with item types and units defined in the main data block.

A valid CIF is essentially a collection of valid CIF blocks.  It
may be the case that inter-block relationships need to be checked,
so there may be some non-trivial block-level checking to be 
performed.

<<A valid CIF block>>=
class ValidCifBlock(CifBlock):
    <<Initialise with dictionary>>
    <<Match items with dictionaries>>
    <<Data validation functions>>
    <<Run data checks>>
    <<Check input data>>
    <<Validation report>>

<<Initialise with dictionary>>=
def __init__(self,diclist = [],*args,**kwords):
    CifBlock.__init__(self,*args,**kwords)    
    dic_as_dic_list = map(CifDic,diclist)
    # the next line creates a dictionary of cif dictionary objects,
    # indexed by dictionary name+version
    self.dicdic = {}
    for a in dic_as_dic_list:
        self.dicdic[a.dicname]=a
    self.item_match = {}
    self.match_items()
    print "Item matches:"
    for a,b in self.item_match.items():
        print "%s: %s" % (a,b)
    self.check_funs = [
	self.check_item_type,
	self.check_item_enum]   # functions which check conformance
    self.res = {}        #results of data checks
    if not self.run_data_checks():
	raise CifError, self.report()

<<Match items with dictionaries>>=
def match_items(self):
        for cif_item in self.keys():
	    self.item_match.setdefault(cif_item,None)   # default value
	    if not self.item_match[cif_item]:  #not yet found
	        for name,cifdic in self.dicdic.items():
                    #print "Searching for %s in %s" % (cif_item,name)
	            if cifdic.has_key(cif_item):
                        self.item_match[cif_item]=name

@ We define a series of methods which we collect into a list,
which we then execute in a series.

<<Data validation functions>>=
<<Single item data checks>>
<<Looped item data checks>>

@ These data checks are those that can be performed on a single
item in isolation, for example numeric or not, is referenced or
not.

<<Single item data checks>>=
def check_item_type(self,item_name,item_val,dictionary_name,verbose):
    if dictionary_name:
        res = self.dicdic[dictionary_name].validate_type(item_name,item_val)
        if res and verbose: 
           print "%s passes type check" % item_name
        elif not res:
           print "%s fails type check" % item_name
        return res

def check_item_enum(self,item_name,item_val,dictionary_name,verbose):
    if dictionary_name:
        res = self.dicdic[dictionary_name].validate_enum(item_name,item_val)
        if res and verbose: 
           print "%s passes enum check" % item_name
        elif res == False:
           print "%s fails enum check" % item_name
        return res

<<Looped item data checks>>=


@ Run all of these data checks. The complicated line creates a dictionary
indexed by checking function with values [(item,result),...].

<<Run data checks>>=
def run_data_checks(self,verbose=False):
    self.res = {}
    for check_fun in self.check_funs:
        self.res[check_fun.__name__]= map(lambda b:(b,check_fun(b,self[b],self.item_match[b],verbose)),self.keys())
    # return false and list of baddies if anything didn't match
    print "Res: " + `self.res`
    baddies = map(lambda a:[a,filter(lambda b:b[1]==False,self.res[a])],self.res.keys())
    # if even one false one is found, this should trigger
    print "Baddies:" + `baddies`
    isinvalid = not (len(filter(lambda a:len(a[1])>0,baddies))>0)
    return isinvalid,baddies

@ Report back.  We summarize the contents of self.res
<<Validation report>>=
def report(self):
   import cStringIO
   outstr = cStringIO.StringIO()
   outstr.write( "Validation results\n")
   outstr.write( "------------------\n")
   for fn in self.res.keys():
       it = self.res[fn]      #an optimization
       failed = filter(lambda a: a[1] == False, it)
       passed = filter(lambda a: a[1], it)
       na = filter(lambda a: a[1] == None, it)
       outstr.write("Test %s: Passed %d, Failed %d, Not applicable %d\n" % \
	      (fn,len(passed),len(failed),len(na)))
       if len(failed)>0:
          for res in failed:
              outstr.write( "  Failed: %s %s\n" % (fn,res[0]))
   return outstr.getvalue()

<<Check input data>>=
def single_item_check(self,item_name,item_value):
    self.item_match.setdefault(item_name,None)
    if not right_dic:
        for name,cifdic in self.dicdic.items():
            if cifdic.has_key(cif_item):
                self.item_match[cif_item]=name
    for check_fun in self.check_funs:
	check_fun(item_name,item_value,self.item_match[cif_item])

<<A valid CIF file>>=
class ValidCifFile(CifFile):
    <<Initialise valid CIF>>
    <<Redefine add new block>>
    <<Check and report on validity>>

<<Initialise valid CIF>>=
def __init__(self,filename,diclist=[],*args,**kwargs):
    CifFile.__init__(self,filename,*args,**kwargs)
    self.diclist = diclist        #store here as well
    for blockname in self.keys():
	self.dictionary[blockname]=ValidCifBlock(data=self.dictionary[blockname],diclist=self.diclist)

@ Whenever a new block is added, we have to additionally update our
match array and perform a validation run.  This definition shadows
the definition in the parent class.

<<Redefine add new block>>=
def NewBlock(self,blockname,blockcontents):
    newblockname = CifFile.NewBlock(self,blockname,blockcontents)
    # dictionary[newblockname] is now a CifBlock object.  We
    # turn it into a ValidCifBlock object
    self.dictionary[newblockname] = ValidCifBlock(diclist=self.diclist,
                                     data=self.dictionary[newblockname])

@ Checking the file.  We check each data block, and put the reports together.

<<Check and report on validity>>=
def check_and_report(self):
    for blockname in self.keys():
        print "\n Report for block %s\n" % blockname
        self[blockname].run_data_checks()
        print self[blockname].report()
