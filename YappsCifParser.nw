@
Noweb literate programming file for Cif grammar and parser specification.
We are using Amit Patel's excellent context-sensitive Yapps2 parser.  
This was chosen
because it enables us to process long semicolon delimited strings without
running into Python recursion limits.  In the original kjParsing implementation,
it was impossible to get the lexer to return a single line of text within
the semicolon-delimited string as that re would have matched a single line
of text anywhere in the file.  The resulting very long match expression
only worked for text strings less than about 9000 characters in length.
For further information about Yapps2, see 
http://theory.stanford.edu/~amitp/Yapps/

<<*>>=
<<Helper functions>>
%%
parser CifParser:
    <<Regular expressions>>
    <<Grammar specification>>
%%
@   Helper functions.

We have a monitor function which we can call to save the last parsed
value (and print, if we are debugging).   We also have functions for
stripping off delimiters from strings.  Finally, we match up our
loops after reading them in.  Note that we have function stripextras,
which is only for semicolon strings, and stripstring, which is for
getting rid of the inverted commas.

<<Helper functions>>=
# An alternative specification for the Cif Parser, based on Yapps2
# by Amit Patel (http://theory.stanford.edu/~amitp/Yapps)
#
# helper code: we define our match tokens
lastval = ''
def monitor(location,value):
    global lastval
    #print 'At %s: %s' % (location,`value`)
    lastval = `value`
    return value

def stripextras(value):
    # we get rid of semicolons and leading/trailing terminators etc.
     import re
     jj = re.compile("[\n\r\f \t\v]*")
     semis = re.compile("[\n\r\f \t\v]*[\n\r\f]\n*;")
     cut = semis.match(value)
     if cut:
          nv = value[cut.end():len(value)-2]
          if nv[-1]=='\r': nv = nv[:-1]
     else: nv = value
     cut = jj.match(nv)
     if cut:
          return stripstring(nv[cut.end():])
     return nv

# helper function to get rid of inverted commas etc.

def stripstring(value):
     if value:
         if value[0]== '\'' and value[-1]=='\'':
           return value[1:-1]
         if value[0]=='"' and value[-1]=='"':
           return value[1:-1]
     return value

# helper function to create a dictionary given a set of
# looped datanames and data values

def makeloop(namelist,itemlist,context):
    noitems = len(namelist)
    nopoints = divmod(len(itemlist),noitems)
    if nopoints[1]!=0:    #mismatch
        raise "CifError:loop item mismatch"
    nopoints = nopoints[0]
    newdict = {}
    for i in range(0,noitems):
        templist = []
        for j in range(0,nopoints):
            templist.append(itemlist[j*noitems + i])
        newdict.update({namelist[i]:templist})
    context.append(newdict)
    #print 'Contructed loop with items: '+`newdict`
    return {}    # to keep things easy

#
@

The regular expressions aren't quite as easy to deal with as in kjParsing;
in kjParsing we could pass string variables as re arguments, but here we have
to have a raw string.

<<Regular expressions>>=
# first handle whitespace and comments, keeping whitespace
# before a semicolon
ignore: "([ \t\v\n\r\f](?!;))|[ \t\v]"
ignore: "#.*[\n\r\f](?!;)"
ignore: "#.*"
# now the tokens
token LBLOCK:  "(L|l)(O|o)(O|o)(P|p)_"        # loop_
token data_name: "_[][!%&\(\)*+,./:<=>?@0-9A-Za-z\\\\^`{}\|~\"#$';_-]+" #_followed by stuff
token data_heading: "(D|d)(A|a)(T|t)(A|a)_[][!%&\(\)*+,./:<=>?@0-9A-Za-z\\\\^`{}\|~\"#$';_-]+"
token data_value_1: "([^\s\"#$'_][^\s]+)|'(('[^\s])|([^\n\r\f']))*'|\"((\"[^\s])|([^\n\r\f']))*\""
token data_value_2: "([^\s\"$#';][^\s]*)|\"((\"[^\s])|([^\"\n\r\f]))*\"|'(('[^\s])|([^'\n\r\f]))*'"
token start_sc_line: "(\n|\r\n|\f);([^\n\r\f])*(\r\n|\r|\n|\f)"
token sc_line_of_text: "[^;\r\n\f]([^\r\n\f])*(\r\n|\r|\n|\f)"
token end_sc_line: ";"
token END: '$'

@

The grammar specification is adapted from the kjParsing version.  We now merge our actions
in with the specification, rather than binding rules as we were doing.  The final returned
value is a dictionary, with each key a datablock name.  The value attached to each key is
an entire dictionary for that block, with special member 'loops' containing an array of
dictionaries, one for each loop block.  In order to construct this properly, we pass the
current value of 'loops' to the data rule, so that when a loop is found it can be
appended to this array.

<<Grammar specification>>=
# now the rules

rule input: ((
            dblock              {{maindict = dblock }}
            (
            dblock              {{maindict.update(monitor('input',dblock))}} #
            )*
            END                
            )
            |
            (
             END                 {{maindict = {} }}
            ))                    {{return maindict}}

     rule dblock: (data_heading           {{dict={data_heading[5:]:{"loops":[]} } }}   # a data heading
                  (
                   dataseq@<<dict[data_heading[5:]]["loops"]>>    {{dict[data_heading[5:]].update(dataseq)}}
                  )*
                   )                      {{return monitor('dblock',dict)}} # but may be empty

     rule dataseq@<<loop_array>>:  data@<<loop_array>>  {{datadict=data}} 
		       (
                       data@<<loop_array>>           {{datadict.update(data)}}
                       )*                           {{return monitor('dataseq',datadict)}}

     rule data@<<loop_array>>:  data_loop@<<loop_array>> {{return data_loop}} 
                        | 
		        datakvpair      {{return datakvpair}} #kv pair

     rule datakvpair: data_name data_value  {{return {data_name:data_value} }} # name-value
     rule data_value: (data_value_1          {{thisval = stripstring(data_value_1)}}
		      |  
		      data_value_2          {{thisval = stripstring(data_value_2)}}
                      |
                      sc_lines_of_text      {{thisval = stripextras(sc_lines_of_text)}}
                      )                     {{return monitor('data_value',thisval)}}

     rule sc_lines_of_text: start_sc_line   {{lines = start_sc_line}}
                            (
                            sc_line_of_text {{lines = lines+sc_line_of_text}}
                            )*
                            end_sc_line     {{return monitor('sc_line_of_text',lines+end_sc_line)}}

     rule data_loop@<<loop_array>>: LBLOCK loopfield loopvalues {{return makeloop(loopfield,loopvalues,loop_array)}}

     rule loopfield: data_name      {{loop=[data_name]}}
		     (
		     data_name      {{loop.append(data_name)}}
		     )*             {{return loop}} # sequence of data names 

     rule loopvalues: ( data_value    {{loop=[data_value]}}
		       ( 
                       data_value     {{loop.append(monitor('loopval',data_value))}}
                       )*             
		       )	      {{return loop}}

