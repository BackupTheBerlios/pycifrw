<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Programming with PyCIFRW and PySTARRW</TITLE>
<META NAME="description" CONTENT="Programming with PyCIFRW and PySTARRW">
<META NAME="keywords" CONTENT="documentation">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="documentation.css">

</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<P>

<P>
<H1 ALIGN="CENTER">Programming with PyCIFRW and PySTARRW</H1>
<DIV CLASS="author_info">

</DIV>
PyCIFRW provides facilities for reading, manipulating and writing
CIF and STAR files. In addition, CIF files and dictionaries may be
validated against DDL1/2 dictionaries. 

<P>

<H1><A NAME="SECTION00010000000000000000">
<SPAN CLASS="arabic">1</SPAN> Installing and Initialising PyCIFRW</A>
</H1>

<P>
Assuming python is installed, you can unpack the distribution into
a temporary directory, and then type ``<TT>python setup.py</TT>''
from within this temporary directory. Upon completion of this command,
the python distutils installer will have placed four files into the
python packages directory: <TT>CifFile.py</TT>, <TT>StarFile.py,
yappsrt.py</TT> and <TT>YappsStarParser.py</TT>. It is then sufficient
to import <TT>CifFile.py</TT> to access all CIF features: 

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;&nbsp;import&nbsp;CifFile
</DD>
</DL>
<P>

<H1><A NAME="SECTION00020000000000000000">
<SPAN CLASS="arabic">2</SPAN> Working with CIF files</A>
</H1>

<P>

<H2><A NAME="SECTION00021000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating a CifFile object</A>
</H2>

<P>
CIF files are represented in PyCIFRW as <TT>CifFile</TT> objects.
These objects behave identically to Python dictionaries, with some
additional methods. CIF files can be created by calling the <TT>ReadCif</TT>
function:

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;&nbsp;cf&nbsp;=&nbsp;CifFile.ReadCif(``mycif.cif'')
</DD>
</DL>Optionally, the maximum input line length can be specified; it defaults
to the CIF 1.1 value of 2048 characters.

<P>
Errors are raised if CIF syntax/grammar violations are encountered
in the input file or line length limits are exceeded.

<P>

<H3><A NAME="SECTION00021100000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating a new CifFile</A>
</H3>

<P>
A new <TT>CifFile</TT> object is usually created empty:

<P>

<DL COMPACT>
<DT>
<DD>cf&nbsp;=&nbsp;CifFile.CifFile()
</DD>
</DL>You will need to create at least one <TT>CifBlock</TT> object to hold
your data:

<P>

<DL COMPACT>
<DT>
<DD>myblock&nbsp;=&nbsp;CifFile.CifBlock()

<P>
cf['a_block']&nbsp;=&nbsp;myblock
</DD>
</DL>A <TT>CifBlock</TT> object may be initialised with another <TT>CifBlock</TT>,
in which case a copy operation is performed, or with a tuple or list
of tuples containing key, value pairs. These are inserted into the
new <TT>CifBlock</TT> using <TT>AddCifItem</TT> (see below).

<P>

<H2><A NAME="SECTION00022000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Manipulating values in a CIF file</A>
</H2>

<P>

<H3><A NAME="SECTION00022100000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Accessing data</A>
</H3>

<P>
The simplest form of access is using standard Python square bracket
notation. Data blocks and data names within each data block are referenced
identically to normal Python dictionaries:

<P>

<DL COMPACT>
<DT>
<DD>my_data&nbsp;=&nbsp;cf['a_data_block']['_a_data_name']
</DD>
</DL>All values are strings with CIF syntactical elements stripped, that
is, no enclosing quotation marks or semicolons are included in the
values. The value associated with a <TT>CifFile</TT> dictionary key
is always a <TT>CifBlock</TT> object. All standard Python dictionary
methods (e.g. <TT>get, update, items, keys</TT>) are available for
both <TT>CifFile</TT> and <TT>CifBlock</TT> objects.

<P>
If a data name occurs in a loop, a list of string values is returned
for the value of that dataname. However, in practice, looped data
is usually only useful in combination with other values from the same
loop. <TT>CifBlock</TT> method <TT>GetLoop(dataname)</TT> will return
all data in the loop containing dataname as a <TT>CifLoopBlock</TT>
object, which provides the same methods as the <TT>CifBlock</TT>.
For example, <TT>keys()</TT> returns a list of datanames in the loop.
Additionally, loop packets can be accessed by accessing the nth value
in the <TT>CifLoopBlock</TT> object:

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;&nbsp;lb&nbsp;=&nbsp;cb.GetLoop(``_item_5'')

<P>
&gt;&gt;&gt;&nbsp;lb[0]

<P>
['1',&nbsp;'a',&nbsp;'5']
</DD>
</DL>which also means that it is simple to loop over all packets using
default Python behaviour:

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;&nbsp;for&nbsp;j&nbsp;in&nbsp;lb:&nbsp;print&nbsp;`j`&nbsp;

<P>
['1',&nbsp;'a',&nbsp;'5']&nbsp;

<P>
['2',&nbsp;'b',&nbsp;'6']&nbsp;

<P>
['3',&nbsp;'c',&nbsp;'7']&nbsp;

<P>
['4',&nbsp;'d',&nbsp;'8']&nbsp;
</DD>
</DL>The corresponding datanames are accessible through method GetItemOrder:

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;&nbsp;lb.GetItemOrder()

<P>
['_item_5',&nbsp;'_item_7',&nbsp;'_item_6']
</DD>
</DL>An alternative way of accessing loop data is through the built in
<TT>CifLoopBlock</TT> iterator called <TT>flat_iterator</TT>, which
on each call to the iterator object returns a <TT>CifLoopBlock</TT>
with single-valued datanames (for most purposes identical to a Python
dictionary):

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;&nbsp;t&nbsp;=&nbsp;lb.flat_iterator()&nbsp;

<P>
&gt;&gt;&gt;&nbsp;for&nbsp;a&nbsp;in&nbsp;t:&nbsp;print&nbsp;`a[&#34;_item_7&#34;]`&nbsp;

<P>
'a'&nbsp;'b'&nbsp;'c'&nbsp;'d'&nbsp;
</DD>
</DL>
<P>

<H3><A NAME="SECTION00022200000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Changing or adding data values</A>
</H3>

<P>
If many operations are going to be performed on a single data block,
it is convenient to assign that block to a new variable:

<P>

<DL COMPACT>
<DT>
<DD>cb&nbsp;=&nbsp;cf['my_block']
</DD>
</DL>A new data name and value may be added, or the value of an existing
name changed, by straight assignment:

<P>

<DL COMPACT>
<DT>
<DD>cb['_new_data_name']&nbsp;=&nbsp;4.5

<P>
cb['_old_data_name']&nbsp;=&nbsp;'cucumber'
</DD>
</DL>Old values are overwritten silently. Note that values may be strings
or numbers. 

<P>
If a list is given as the value instead of a single string or number,
a new loop is created containing this one data name, looped. If this
data name already appeared in a loop, any looped data values which
may have co-occurred in the loop are deleted. As this is not necessarily
the desired behaviour, you may wish to access the loop block using
the <TT>GetLoop</TT> method described above.

<P>
Alternatively, the underlying AddCifItem method can be used to add
multiple looped and unlooped data items in a single command. <TT>AddCifItem</TT>
is called with a 2-element tuple argument. The first element of the
tuple is either a single dataname, or a list or tuple of datanames.
The second element is either a single value (in the case of a single
name in the first element) or a list, each element of which is a list
of values taken by the corresponding dataname in the first element.
A nested tuple of datanames in the first element together with the
corresponding nested tuple of lists in the second element will become
a loop block in the Cif file.

<P>
Another method, <TT>AddToLoop(dataname,newdata),</TT> adds <TT>newdata</TT>
to the pre-existing loop containing <TT>dataname</TT>, silently overwriting
duplicate data. <TT>Newdata</TT> should be a Python dictionary of
dataname - datavalue pairs, with <TT>datavalue</TT> a list of new/replacement
values.

<P>
Note that lists (and objects) returned by PyCIFRW actually represent
the list currently inside the CifBlock, and therefore any modification
to them will modify the stored list. While this is often the desired
behaviour, if you intend to alter any such lists in other parts of
your program while maintaining CIF integrity, you should first copy
them to avoid destroying the loop structure:

<P>

<DL COMPACT>
<DT>
<DD>mysym&nbsp;=&nbsp;cb['_symmetry_ops'][:]

<P>
mysym.append('x-1/2,y+1/2,z')
</DD>
</DL>
<P>

<H4><A NAME="SECTION00022210000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Examples using loops</A>
</H4>

<P>

<H5><A NAME="SECTION00022211000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Adding/replacing a single item with looped values:</A>
</H5>

<P>

<DL COMPACT>
<DT>
<DD>cb['_symmetry']&nbsp;=&nbsp;['x,y,z','-x,-y,-z','x+1/2,y,z']
</DD>
</DL>results in an output fragment

<P>

<DL COMPACT>
<DT>
<DD>loop_

<P>
&nbsp;&nbsp;&nbsp;_symmetry

<P>
&nbsp;&nbsp;&nbsp;x,y,z

<P>
&nbsp;&nbsp;&nbsp;-x,-y,-z

<P>
&nbsp;&nbsp;&nbsp;x+1/2,y,z
</DD>
</DL>
<P>

<H5><A NAME="SECTION00022212000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Adding a complete loop:</A>
</H5>

<P>

<DL COMPACT>
<DT>
<DD>cb.AddCifItem(([['_example','_example_detail']],

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[['123.4','4567.8'],

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;['small&nbsp;cell','large&nbsp;cell']]]))
</DD>
</DL>results in an output fragment:

<P>

<DL COMPACT>
<DT>
<DD>loop_

<P>
&nbsp;&nbsp;&nbsp;_example

<P>
&nbsp;&nbsp;&nbsp;_example_detail

<P>
&nbsp;&nbsp;&nbsp;123.4&nbsp;'small&nbsp;cell'

<P>
&nbsp;&nbsp;&nbsp;4567.8&nbsp;'large&nbsp;cell'
</DD>
</DL>
<P>

<H5><A NAME="SECTION00022213000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Appending a new dataname to a pre-existing loop:</A>
</H5>

<P>

<DL COMPACT>
<DT>
<DD>cb.AddToLoop(

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'_example',{'_comment':[''not&nbsp;that&nbsp;small'',''Big&nbsp;and&nbsp;beautiful'']}

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
</DD>
</DL>changes the previous output to be

<P>

<DL COMPACT>
<DT>
<DD>loop_

<P>
&nbsp;&nbsp;&nbsp;_example

<P>
&nbsp;&nbsp;&nbsp;_example_detail

<P>
&nbsp;&nbsp;&nbsp;_comment

<P>
&nbsp;&nbsp;&nbsp;123.4&nbsp;'small&nbsp;cell'&nbsp;'not&nbsp;that&nbsp;small'

<P>
&nbsp;&nbsp;&nbsp;4567.8&nbsp;'large&nbsp;cell'&nbsp;'Big&nbsp;and&nbsp;beautiful'
</DD>
</DL>
<P>

<H5><A NAME="SECTION00022214000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Changing pre-existing data in a loop:</A>
</H5>

<P>

<DL COMPACT>
<DT>
<DD>cb.AddToLoop('_comment',{'_example':['12.2','12004']})

<P>
</DD>
</DL>changes the previous example to

<P>

<DL COMPACT>
<DT>
<DD>loop_

<P>
&nbsp;&nbsp;&nbsp;_example

<P>
&nbsp;&nbsp;&nbsp;_example_detail

<P>
&nbsp;&nbsp;&nbsp;_comment

<P>
&nbsp;&nbsp;&nbsp;12.2&nbsp;'small&nbsp;cell'&nbsp;'not&nbsp;that&nbsp;small'

<P>
&nbsp;&nbsp;&nbsp;12004&nbsp;'large&nbsp;cell'&nbsp;'Big&nbsp;and&nbsp;beautiful'
</DD>
</DL>
<P>

<H5><A NAME="SECTION00022215000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Adding a new loop packet. </A>
</H5>

<P>
PyCifRW does not (yet) directly support this: the following code shows
one way to accomplish this indirectly for the above example.

<P>

<DL COMPACT>
<DT>
<DD>newdata=&nbsp;{'_example':['101.1','255'],

<P>
&nbsp;'_example_detail':['medium&nbsp;cell','also&nbsp;medium'],

<P>
&nbsp;'_comment':['manageable','still&nbsp;manageable']

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

<P>
olddata&nbsp;=&nbsp;cb.GetLoop('_example')&nbsp;#(key,value)&nbsp;list

<P>
map(lambda&nbsp;a:newdata[a[0]].extend(a[1]),loopdata)

<P>
cb.AddCifItem((newdata.keys(),newdata.values()))
</DD>
</DL>Note that, as the lists returned by PyCIFRW are direct pointers to
the original lists, it is possible to extend them directly (e.g. <TT>cb['_example'].append('101.1')</TT>),
however, this bypasses all data value syntax checks and loop length
checks and is not recommended.

<P>

<H2><A NAME="SECTION00023000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Writing Cif Files</A>
</H2>

<P>
The <TT>CifFile</TT> method <TT>WriteOut</TT> returns a string which
may be passed to an open file descriptor:

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;outfile&nbsp;=&nbsp;open(``mycif.cif'')

<P>
&gt;&gt;&gt;outfile.write(cf.WriteOut())
</DD>
</DL>An alternative method uses the built-in Python <TT>str()</TT> function:

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;outfile.write(str(cf))
</DD>
</DL><TT>WriteOut</TT> takes an optional argument, <TT>comment</TT>, which
should be a string containing a comment which will be placed at the
top of the output file. This comment string must already contain #
characters at the beginning of lines:

<P>

<DL COMPACT>
<DT>
<DD>&gt;&gt;&gt;outfile.write(cf.WriteOut(``#This&nbsp;is&nbsp;a&nbsp;test&nbsp;file''))
</DD>
</DL>There is currently no way to easily specify the order of output of
items within a <TT>CifFile</TT> or <TT>CifBlock. </TT>

<P>

<H1><A NAME="SECTION00030000000000000000">
<SPAN CLASS="arabic">3</SPAN> Dictionaries and Validation</A>
</H1>

<P>

<H2><A NAME="SECTION00031000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Dictionaries</A>
</H2>

<P>
DDL dictionaries may also be read into <TT>CifFile</TT> objects. For
this purpose, <TT>CifBlock</TT> objects automatically support save
frames (used in DDL2 dictionaries), which are accessed using the <TT>``saves''</TT>
key. The value of this key is a collection of <TT>CifBlock</TT> objects
indexed by save frame name, and available operations are similar to
those available for a <TT>CifFile</TT>, which is also a collection
of <TT>CifBlock</TT>s.

<P>
A <TT>CifDic</TT> object hides the difference between DDL1 dictionaries,
where all definitions are separate data blocks, and DDL2 dictionaries,
where all definitions are in save frames of a single data block. A
<TT>CifDic</TT> is initialised with a single file name or <TT>CifFile</TT>
object:

<P>

<DL COMPACT>
<DT>
<DD>cd&nbsp;=&nbsp;CifFile.CifDic(``cif_core.dic'')
</DD>
</DL>Definitions are accessed using the usual notation, e.g. <TT>cd['_atom_site_aniso_label']</TT>.
Return values are always <TT>CifBlock</TT> objects. Additionally,
the <TT>CifDic</TT> object contains a number of instance variables
derived from dictionary global data:

<P>
<DL>
<DT><STRONG>dicname</STRONG></DT>
<DD>The dictionary name + version as given in the dictionary 
</DD>
<DT><STRONG>diclang</STRONG></DT>
<DD>'DDL1' or 'DDL2'
</DD>
<DT><STRONG>typedic</STRONG></DT>
<DD>Python dictionary matching typecode with compiled regular
expression
</DD>
</DL>
<TT>CifDic</TT> objects provide a large number of validation functions,
which all return a Python dictionary which contains at least the key
<TT>``result''</TT>. <TT>``result''</TT> takes the values
<TT>True</TT>, <TT>False</TT> or <TT>None</TT> depending on the success,
failure or non-applicability of each test. In case of failure, additional
keys are returned depending on the nature of the error.

<P>

<H2><A NAME="SECTION00032000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Validation</A>
</H2>

<P>
A top level function is provided for convenient validation of CIF
files:

<P>

<DL COMPACT>
<DT>
<DD>CifFile.validate(``mycif.cif'',dic&nbsp;=&nbsp;''cif_core.dic'')
</DD>
</DL>This returns a tuple <TT>(valid_result, no_matches)</TT>. <TT>valid_result</TT>
and <TT>no_matches</TT> are Python dictionaries indexed by block
name. For <TT>valid_result</TT>, the value for each block is itself
a dictionary indexed by <TT>item_name</TT>. The value attached to
each item name is a list of <TT>(check_function, check_result)</TT>
tuples, with <TT>check_result</TT> a small dictionary containing
at least the key <TT>``result''</TT>. All tests which passed or
were not applicable are removed from this dictionary, so result is
always <TT>False</TT>. Additional keys contain auxiliary information
depending on the test. Each of the items in <TT>no_matches</TT> is
a simple list of item names which were not found in the dictionary.

<P>
If a simple validation report is required, the function <TT>validate_report</TT>
can be called on the output of the above function, printing a simple
ASCII report. This function can be studied as an example of how to
process the complex structure returned by the '<TT>validate</TT>'
function.

<P>

<H3><A NAME="SECTION00032100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Limitations on validation</A>
</H3>

<P>

<OL>
<LI>(DDL2 only) When validating data dictionaries themselves, no checks
are made on group and subgroup consistency (e.g. that a specified
subgroup is actually defined).
</LI>
<LI>(DDL1 only) Some _type_construct attributes in the DDL1 spec file
are not machine-readable, so values cannot be checked for consistency
</LI>
</OL>

<P>

<H2><A NAME="SECTION00033000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ValidCifFile objects</A>
</H2>

<P>
A <TT>ValidCifFile</TT> object behaves identically to a <TT>CifFile</TT>
object with the additional characteristic that it is valid against
the given dictionary object. Any attempt to set a data value, or add
or remove a data name, that would invalidate the object raises a <TT>ValidCifFile</TT>
error. 

<P>
Additional keywords for initialisation are:

<P>
<DL>
<DT><STRONG>dic</STRONG></DT>
<DD>A <TT>CifDic</TT> object to use in validation
</DD>
<DT><STRONG>diclist</STRONG></DT>
<DD>A list of <TT>CifFile</TT> objects or filenames to be merged
into a <TT>CifDic</TT> object (see below)
</DD>
<DT><STRONG>mergemode</STRONG></DT>
<DD>Choose merging method (one of '<TT>strict</TT>','<TT>overlay</TT>',
'<TT>replace</TT>')
</DD>
</DL>

<P>

<H2><A NAME="SECTION00034000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Merging dictionaries</A>
</H2>

<P>
PyCIFRW provides a top-level function to merge DDL1/2 dictionary files.
It takes a list of CIF filenames or <TT>CifFile</TT> objects, and
a <TT>mergemode</TT> keyword argument. CIF files are merged from left
to right, that is, the second file in the list is merged into the
first file in the list and so on.

<P>
For completeness we list the arguments of the <TT>CifFile merge</TT>
method:

<P>
<DL>
<DT><STRONG>new_block_set</STRONG></DT>
<DD>(first argument, no keyword) The new dictionary
to be merged into the current dictionary
</DD>
<DT><STRONG>mode</STRONG></DT>
<DD>merging mode to use ('strict', 'overlay' or 'replace')
</DD>
<DT><STRONG>single_block</STRONG></DT>
<DD>a two element list <TT>[oldblockname, newblockname]</TT>,
where <TT>oldblockname</TT> in the current file is merged with <TT>newblockname</TT>
in the new file. This is useful when blocknames don't match
</DD>
<DT><STRONG>idblock</STRONG></DT>
<DD>This block is ignored when merging - useful when merging
DDL1 dictionaries in strict mode, in which case the <TT>on_this_dictionary</TT>
block would cause an error.
</DD>
</DL>

<P>

<H3><A NAME="SECTION00034100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Limitations on merging</A>
</H3>

<P>
In overlay mode, the COMCIFS recommendations require that, when both
definitions contain identical attributes which can be looped, the
merging process should construct those loops and include both sets
of data in the new loop. 

<P>
This is not yet implemented in PyCIFRW, as it involves checking the
DDL1/DDL2 spec to determine which attributes may be looped together.

<P>

<H1><A NAME="SECTION00040000000000000000">
<SPAN CLASS="arabic">4</SPAN> Working with STAR files</A>
</H1>

<P>

<H2><A NAME="SECTION00041000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating STAR files</A>
</H2>

<P>
Star files are created entirely analogously to CIF files, using the
<TT>StarFile</TT> object or <TT>ReadStar</TT> function.

<P>

<H2><A NAME="SECTION00042000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> Manipulating values</A>
</H2>

<P>
The usual square bracket notation applies, as for <TT>CifFile</TT>
and <TT>CifBlock</TT> objects. <TT>StarFiles</TT> are built out of
<TT>StarBlock</TT> objects in exactly the same way as <TT>CifFile</TT>
objects are built out of <TT>CifBlock</TT> objects. <TT>StarBlock</TT>
objects can contain any number of <TT>LoopBlock</TT> objects, which
represent STAR loop blocks. Crucially, these <TT>LoopBlock</TT> objects
may contain nested loops, which are also <TT>LoopBlock</TT> objects.
Loops are inserted into a <TT>LoopBlock</TT> by calling the <TT>insert_loop</TT>
method, and may be nested to an arbitrary level.

<P>

<H3><A NAME="SECTION00042100000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Iterators</A>
</H3>

<P>
Any LoopBlock object has two iterator methods: <TT>recursive_iter</TT>
and <TT>flat_iterator</TT>. On each call of the iterator created
by a <TT>recursive_iter</TT> call, a Python dictionary is returned
with single-valued keys corresponding to a single set of values. If
there are multiple trees of nested loops in a <TT>LoopBlock</TT>,
each tree is iterated over separately, as there is no reason that
looped values inside a second loop block would have any relationship
with values inside a first loop block. This iterator will thus return
all possible sets of values for the <TT>LoopBlock</TT>.

<P>
The <TT>flat_iterator</TT> method does not dig down into nested loops.
Instead, iterators created from it return a new <TT>LoopBlock</TT>
with key-value pairs corresponding to a single top-level packet; nested
loops are included, but they also have only data corresponding to
the selected top-level packet available. This iterator thus iterates
through the top-level packets, collapsing the nesting level by one.

<P>

<H1><A NAME="SECTION00050000000000000000">
<SPAN CLASS="arabic">5</SPAN> Example programs</A>
</H1>

<P>
A program which uses PyCIFRW for validation, <TT>validate_cif.py</TT>,
is included in the distribution in the Programs subdirectory. It will
validate a CIF file (including dictionaries) against one or more dictionaries
which may be specified by name and version or as a filename on the
local disk. If name and version are specified, the IUCr canonical
registry or a local registry is used to find the dictionary and download
it if necessary.

<P>

<H2><A NAME="SECTION00051000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Usage</A>
</H2>

<P>

<DL COMPACT>
<DT>
<DD>python&nbsp;validate_cif.py&nbsp;[options]&nbsp;ciffile
</DD>
</DL>
<P>

<H2><A NAME="SECTION00052000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Options</A>
</H2>

<P>
<DL>
<DT><STRONG>-version</STRONG></DT>
<DD>show version number and exit
</DD>
<DT><STRONG>-h,-help</STRONG></DT>
<DD>print short help message
</DD>
<DT><STRONG>-d&nbsp;dirname</STRONG></DT>
<DD>directory to find/store dictionary files
</DD>
<DT><STRONG>-f&nbsp;dictname</STRONG></DT>
<DD>filename of locally-stored dictionary
</DD>
<DT><STRONG>-u&nbsp;version</STRONG></DT>
<DD>dictionary version to resolve using registry
</DD>
<DT><STRONG>-n&nbsp;name</STRONG></DT>
<DD>dictionary name to resolve using registry
</DD>
<DT><STRONG>-s</STRONG></DT>
<DD>store downloaded dictionary locally (default True)
</DD>
<DT><STRONG>-c</STRONG></DT>
<DD>fetch and use canonical registry from IUCr
</DD>
<DT><STRONG>-r&nbsp;registry</STRONG></DT>
<DD>location of registry as filename or URL
</DD>
<DT><STRONG>-t</STRONG></DT>
<DD>The file to be checked is itself a DDL2 dictionary
</DD>
</DL>

<P>

<H1><A NAME="SECTION00060000000000000000">
<SPAN CLASS="arabic">6</SPAN> Further information</A>
</H1>

<P>
The source files are in a literate programming format (noweb) with
file extension .nw. HTML documentation generated from these files
and containing both code and copious comments is included in the downloaded
package. Details of interpretation of the current standards as relates
to validation can be found in these files.

<H1><A NAME="SECTION00070000000000000000">
About this document ...</A>
</H1>
 <STRONG>Programming with PyCIFRW and PySTARRW</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2002-2-1 (1.71)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-no_subdir -split 0 -show_section_numbers /tmp/lyx_tmpdir32370cfAcqz/lyx_tmpbuf0/documentation.tex</TT>
<P>
The translation was initiated by James Hester on 2006-03-08
<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
James Hester
2006-03-08
</ADDRESS>
</BODY>
</HTML>
